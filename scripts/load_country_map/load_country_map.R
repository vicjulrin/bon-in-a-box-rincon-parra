# Set session parameters ####

## Specify necessary libraries ####
required_packages <- c("magrittr", "this.path", "rjson", "data.table", "dplyr", "sf", "rnaturalearth", "rnaturalearthdata")

### Check and Install missing packages ####
installed <- installed.packages()[, "Package"]
missing_packages <- setdiff(required_packages, installed)
if (length(missing_packages)) {
  install.packages(missing_packages, repos = "https://packagemanager.posit.co/cran/__linux__/jammy/latest", dependencies = TRUE)
}

### Load libraries ####
packagesList<-list("magrittr") # Explicitly list the required packages throughout the entire routine. Explicitly listing the required packages throughout the routine ensures that only the necessary packages are listed. Unlike 'packagesNeed', this list includes packages with functions that cannot be directly called using the '::' syntax. By using '::', specific functions or objects from a package can be accessed directly without loading the entire package. Loading an entire package involves loading all the functions and objects 
invisible(lapply(packagesList, library, character.only = TRUE))

# Set up the working environment ####

## Set output folder ####
# Option 1: Setting for production pipeline purposes. This is designed for use in a production environment or workflow.
Sys.setenv(outputFolder = "/path/to/output/folder")

# Option 2: Recommended for debugging purposes to be used as a testing environment. This is designed to facilitate script testing and correction
if ( (!exists("outputFolder"))  ) {
  outputFolder<- {x<- this.path::this.path();  file_prev<-  paste0(gsub("/scripts.*", "/output", x), gsub("^.*/scripts", "", x)  ); options<- tools::file_path_sans_ext(file_prev) %>% {c(., paste0(., ".R"), paste0(., "_R"))}; folder_out<- options %>% {.[file.exists(.)]} %>% {.[which.max(sapply(., function(info) file.info(info)$mtime))]}; folder_final<- list.files(folder_out, full.names = T) %>% {.[which.max(sapply(., function(info) file.info(info)$mtime))]} }
}

## Set input folder ####
# Set the 'input' environment variables. The 'input' environment contains the specified inputs from the BiB platform. The input file 'input.json' is generated by executing the 'Run Script' command in the ByB platform.
input <- rjson::fromJSON(file=file.path(outputFolder, "input.json")) # Load input file

# This lines adjusts the input values based on specific conditions to rectify and prevent errors in the input paths
input<- lapply(input, function(y) lapply(y, function(x)  { if (!is.null(x) && length(x) > 0 && grepl("/", x) && !grepl("http://", x)  ) { 
  sub("/output/.*", "/output", outputFolder) %>% dirname() %>%  file.path(x) %>% {gsub("//+", "/", .)}  } else{x} }) %>% unlist()) 


#  Script body ####

## Load map ####
if(input$type_map == "ne_countries") {
  map_country <- rnaturalearth::ne_countries(country = input$country, scale= input$scale, returnclass = "sf") %>% sf::st_transform(input$epsg) %>% sf::st_make_valid() %>% sf::st_make_valid() %>% sf::st_union() %>% sf::st_as_sf()
} else if (input$type_map == "ne_states") {
  map_country <- rnaturalearth::ne_states(country = input$country, scale= input$scale, returnclass = "sf") %>% sf::st_transform(input$epsg) %>% sf::st_make_valid() %>% sf::st_make_valid() %>% sf::st_union() %>% sf::st_as_sf()
} 

## Adjust projection ####
crs_basemap<- raster::crs( paste0("+init=epsg:", input$epsg) )
if (sf::st_crs(map_country)$epsg != input$epsg) {
  map_country <- map_country %>% sf::st_transform(input$epsg)
}

## Write results ####
map_country_path<- file.path(outputFolder, paste0("map_country", "GeoJSON")) # Define the file path
sf::st_write(map_country, map_country_path, delete_dsn= T, driver = "GeoJSON") # Write the shapefile to the specified path

# Define final output list
output<- list(map_country= map_country_path)


#### Outputing result to JSON ####
# Write the output list to the 'output.json' file in JSON format
setwd(outputFolder)
jsonlite::write_json(output, "output.json", auto_unbox = TRUE, pretty = TRUE)